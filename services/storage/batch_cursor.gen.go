// Generated by tmpl
// https://github.com/benbjohnson/tmpl
//
// DO NOT EDIT!
// Source: batch_cursor.gen.go.tmpl

package storage

import (
	"errors"

	"github.com/influxdata/influxdb/tsdb"
)

// ********************
// Float BatchCursor

type floatFilterBatchCursor struct {
	tsdb.FloatBatchCursor
	cond expression
	m    *singleValue
	t    []int64
	v    []float64
	tb   []int64
	vb   []float64
}

func newFloatFilterBatchCursor(cur tsdb.FloatBatchCursor, cond expression) *floatFilterBatchCursor {
	return &floatFilterBatchCursor{
		FloatBatchCursor: cur,
		cond:             cond,
		m:                &singleValue{},
		t:                make([]int64, tsdb.DefaultMaxPointsPerBlock),
		v:                make([]float64, tsdb.DefaultMaxPointsPerBlock),
	}
}

func (c *floatFilterBatchCursor) Next() (key []int64, value []float64) {
	pos := 0
	var ks []int64
	var vs []float64

	if len(c.tb) > 0 {
		ks, vs = c.tb, c.vb
		c.tb, c.vb = nil, nil
	} else {
		ks, vs = c.FloatBatchCursor.Next()
	}

LOOP:
	for len(ks) > 0 {
		for i, v := range vs {
			c.m.v = v
			if c.cond.EvalBool(c.m) {
				c.t[pos], c.v[pos] = ks[i], v
				pos++
				if pos >= tsdb.DefaultMaxPointsPerBlock {
					c.tb, c.vb = ks[i+1:], vs[i+1:]
					break LOOP
				}
			}
		}
		ks, vs = c.FloatBatchCursor.Next()
	}

	return c.t[:pos], c.v[:pos]
}

type floatMultiShardBatchCursor struct {
	tsdb.FloatBatchCursor
	shards []*tsdb.Shard
	req    *tsdb.CursorRequest
	cond   expression
	err    error
}

func newFloatMultiShardBatchCursor(cur tsdb.FloatBatchCursor, req *tsdb.CursorRequest, shards []*tsdb.Shard, cond expression) *floatMultiShardBatchCursor {
	if cond != nil {
		cur = newFloatFilterBatchCursor(cur, cond)
	}

	c := &floatMultiShardBatchCursor{
		FloatBatchCursor: cur,
		req:              req,
		shards:           shards,
		cond:             cond,
	}

	return c
}

func (c *floatMultiShardBatchCursor) Err() error        { return c.err }
func (c *floatMultiShardBatchCursor) SeriesKey() string { return c.req.Series }

func (c *floatMultiShardBatchCursor) Next() (key []int64, value []float64) {
RETRY:
	ks, vs := c.FloatBatchCursor.Next()
	if len(ks) == 0 {
		if c.nextBatchCursor() {
			goto RETRY
		}
	}
	return ks, vs
}

func (c *floatMultiShardBatchCursor) nextBatchCursor() bool {
	if len(c.shards) == 0 {
		return false
	}

	var shard *tsdb.Shard
	var cur tsdb.Cursor
	for cur == nil && len(c.shards) > 0 {
		shard, c.shards = c.shards[0], c.shards[1:]
		cur, _ = shard.CreateCursor(c.req)
	}

	var ok bool
	if cur != nil {
		var next tsdb.FloatBatchCursor
		next, ok = cur.(tsdb.FloatBatchCursor)
		if !ok {
			next = FloatEmptyBatchCursor
			c.shards = nil
			c.err = errors.New("expected float cursor")
		} else {
			if c.cond != nil {
				next = newFloatFilterBatchCursor(next, c.cond)
			}
		}
		c.FloatBatchCursor = next
	} else {
		c.FloatBatchCursor = FloatEmptyBatchCursor
	}

	return ok
}

type floatSumBatchCursor struct {
	tsdb.FloatBatchCursor
	ts  int64
	acc float64
}

func (c *floatSumBatchCursor) Next() (key []int64, value []float64) {
	ks, vs := c.FloatBatchCursor.Next()
	if len(ks) == 0 {
		return nil, nil
	}

	ts := ks[0]
	var acc float64

	for {
		for _, v := range vs {
			acc += v
		}
		ks, vs = c.FloatBatchCursor.Next()
		if len(ks) == 0 {
			return []int64{ts}, []float64{acc}
		}
	}
}

type integerFloatCountBatchCursor struct {
	tsdb.FloatBatchCursor
}

func (c *integerFloatCountBatchCursor) Next() (key []int64, value []int64) {
	ks, _ := c.FloatBatchCursor.Next()
	if len(ks) == 0 {
		return nil, nil
	}

	ts := ks[0]
	var acc int64
	for {
		acc += int64(len(ks))
		ks, _ = c.FloatBatchCursor.Next()
		if len(ks) == 0 {
			return []int64{ts}, []int64{acc}
		}
	}
}

type floatEmptyBatchCursor struct{}

var (
	FloatEmptyBatchCursor tsdb.FloatBatchCursor = &floatEmptyBatchCursor{}
)

func (*floatEmptyBatchCursor) Err() error                           { return nil }
func (*floatEmptyBatchCursor) Close()                               {}
func (*floatEmptyBatchCursor) SeriesKey() string                    { return "" }
func (*floatEmptyBatchCursor) Next() (key []int64, value []float64) { return nil, nil }

// ********************
// Integer BatchCursor

type integerFilterBatchCursor struct {
	tsdb.IntegerBatchCursor
	cond expression
	m    *singleValue
	t    []int64
	v    []int64
	tb   []int64
	vb   []int64
}

func newIntegerFilterBatchCursor(cur tsdb.IntegerBatchCursor, cond expression) *integerFilterBatchCursor {
	return &integerFilterBatchCursor{
		IntegerBatchCursor: cur,
		cond:               cond,
		m:                  &singleValue{},
		t:                  make([]int64, tsdb.DefaultMaxPointsPerBlock),
		v:                  make([]int64, tsdb.DefaultMaxPointsPerBlock),
	}
}

func (c *integerFilterBatchCursor) Next() (key []int64, value []int64) {
	pos := 0
	var ks []int64
	var vs []int64

	if len(c.tb) > 0 {
		ks, vs = c.tb, c.vb
		c.tb, c.vb = nil, nil
	} else {
		ks, vs = c.IntegerBatchCursor.Next()
	}

LOOP:
	for len(ks) > 0 {
		for i, v := range vs {
			c.m.v = v
			if c.cond.EvalBool(c.m) {
				c.t[pos], c.v[pos] = ks[i], v
				pos++
				if pos >= tsdb.DefaultMaxPointsPerBlock {
					c.tb, c.vb = ks[i+1:], vs[i+1:]
					break LOOP
				}
			}
		}
		ks, vs = c.IntegerBatchCursor.Next()
	}

	return c.t[:pos], c.v[:pos]
}

type integerMultiShardBatchCursor struct {
	tsdb.IntegerBatchCursor
	shards []*tsdb.Shard
	req    *tsdb.CursorRequest
	cond   expression
	err    error
}

func newIntegerMultiShardBatchCursor(cur tsdb.IntegerBatchCursor, req *tsdb.CursorRequest, shards []*tsdb.Shard, cond expression) *integerMultiShardBatchCursor {
	if cond != nil {
		cur = newIntegerFilterBatchCursor(cur, cond)
	}

	c := &integerMultiShardBatchCursor{
		IntegerBatchCursor: cur,
		req:                req,
		shards:             shards,
		cond:               cond,
	}

	return c
}

func (c *integerMultiShardBatchCursor) Err() error        { return c.err }
func (c *integerMultiShardBatchCursor) SeriesKey() string { return c.req.Series }

func (c *integerMultiShardBatchCursor) Next() (key []int64, value []int64) {
RETRY:
	ks, vs := c.IntegerBatchCursor.Next()
	if len(ks) == 0 {
		if c.nextBatchCursor() {
			goto RETRY
		}
	}
	return ks, vs
}

func (c *integerMultiShardBatchCursor) nextBatchCursor() bool {
	if len(c.shards) == 0 {
		return false
	}

	var shard *tsdb.Shard
	var cur tsdb.Cursor
	for cur == nil && len(c.shards) > 0 {
		shard, c.shards = c.shards[0], c.shards[1:]
		cur, _ = shard.CreateCursor(c.req)
	}

	var ok bool
	if cur != nil {
		var next tsdb.IntegerBatchCursor
		next, ok = cur.(tsdb.IntegerBatchCursor)
		if !ok {
			next = IntegerEmptyBatchCursor
			c.shards = nil
			c.err = errors.New("expected integer cursor")
		} else {
			if c.cond != nil {
				next = newIntegerFilterBatchCursor(next, c.cond)
			}
		}
		c.IntegerBatchCursor = next
	} else {
		c.IntegerBatchCursor = IntegerEmptyBatchCursor
	}

	return ok
}

type integerSumBatchCursor struct {
	tsdb.IntegerBatchCursor
	ts  int64
	acc int64
}

func (c *integerSumBatchCursor) Next() (key []int64, value []int64) {
	ks, vs := c.IntegerBatchCursor.Next()
	if len(ks) == 0 {
		return nil, nil
	}

	ts := ks[0]
	var acc int64

	for {
		for _, v := range vs {
			acc += v
		}
		ks, vs = c.IntegerBatchCursor.Next()
		if len(ks) == 0 {
			return []int64{ts}, []int64{acc}
		}
	}
}

type integerIntegerCountBatchCursor struct {
	tsdb.IntegerBatchCursor
}

func (c *integerIntegerCountBatchCursor) Next() (key []int64, value []int64) {
	ks, _ := c.IntegerBatchCursor.Next()
	if len(ks) == 0 {
		return nil, nil
	}

	ts := ks[0]
	var acc int64
	for {
		acc += int64(len(ks))
		ks, _ = c.IntegerBatchCursor.Next()
		if len(ks) == 0 {
			return []int64{ts}, []int64{acc}
		}
	}
}

type integerEmptyBatchCursor struct{}

var (
	IntegerEmptyBatchCursor tsdb.IntegerBatchCursor = &integerEmptyBatchCursor{}
)

func (*integerEmptyBatchCursor) Err() error                         { return nil }
func (*integerEmptyBatchCursor) Close()                             {}
func (*integerEmptyBatchCursor) SeriesKey() string                  { return "" }
func (*integerEmptyBatchCursor) Next() (key []int64, value []int64) { return nil, nil }

// ********************
// Unsigned BatchCursor

type unsignedFilterBatchCursor struct {
	tsdb.UnsignedBatchCursor
	cond expression
	m    *singleValue
	t    []int64
	v    []uint64
	tb   []int64
	vb   []uint64
}

func newUnsignedFilterBatchCursor(cur tsdb.UnsignedBatchCursor, cond expression) *unsignedFilterBatchCursor {
	return &unsignedFilterBatchCursor{
		UnsignedBatchCursor: cur,
		cond:                cond,
		m:                   &singleValue{},
		t:                   make([]int64, tsdb.DefaultMaxPointsPerBlock),
		v:                   make([]uint64, tsdb.DefaultMaxPointsPerBlock),
	}
}

func (c *unsignedFilterBatchCursor) Next() (key []int64, value []uint64) {
	pos := 0
	var ks []int64
	var vs []uint64

	if len(c.tb) > 0 {
		ks, vs = c.tb, c.vb
		c.tb, c.vb = nil, nil
	} else {
		ks, vs = c.UnsignedBatchCursor.Next()
	}

LOOP:
	for len(ks) > 0 {
		for i, v := range vs {
			c.m.v = v
			if c.cond.EvalBool(c.m) {
				c.t[pos], c.v[pos] = ks[i], v
				pos++
				if pos >= tsdb.DefaultMaxPointsPerBlock {
					c.tb, c.vb = ks[i+1:], vs[i+1:]
					break LOOP
				}
			}
		}
		ks, vs = c.UnsignedBatchCursor.Next()
	}

	return c.t[:pos], c.v[:pos]
}

type unsignedMultiShardBatchCursor struct {
	tsdb.UnsignedBatchCursor
	shards []*tsdb.Shard
	req    *tsdb.CursorRequest
	cond   expression
	err    error
}

func newUnsignedMultiShardBatchCursor(cur tsdb.UnsignedBatchCursor, req *tsdb.CursorRequest, shards []*tsdb.Shard, cond expression) *unsignedMultiShardBatchCursor {
	if cond != nil {
		cur = newUnsignedFilterBatchCursor(cur, cond)
	}

	c := &unsignedMultiShardBatchCursor{
		UnsignedBatchCursor: cur,
		req:                 req,
		shards:              shards,
		cond:                cond,
	}

	return c
}

func (c *unsignedMultiShardBatchCursor) Err() error        { return c.err }
func (c *unsignedMultiShardBatchCursor) SeriesKey() string { return c.req.Series }

func (c *unsignedMultiShardBatchCursor) Next() (key []int64, value []uint64) {
RETRY:
	ks, vs := c.UnsignedBatchCursor.Next()
	if len(ks) == 0 {
		if c.nextBatchCursor() {
			goto RETRY
		}
	}
	return ks, vs
}

func (c *unsignedMultiShardBatchCursor) nextBatchCursor() bool {
	if len(c.shards) == 0 {
		return false
	}

	var shard *tsdb.Shard
	var cur tsdb.Cursor
	for cur == nil && len(c.shards) > 0 {
		shard, c.shards = c.shards[0], c.shards[1:]
		cur, _ = shard.CreateCursor(c.req)
	}

	var ok bool
	if cur != nil {
		var next tsdb.UnsignedBatchCursor
		next, ok = cur.(tsdb.UnsignedBatchCursor)
		if !ok {
			next = UnsignedEmptyBatchCursor
			c.shards = nil
			c.err = errors.New("expected unsigned cursor")
		} else {
			if c.cond != nil {
				next = newUnsignedFilterBatchCursor(next, c.cond)
			}
		}
		c.UnsignedBatchCursor = next
	} else {
		c.UnsignedBatchCursor = UnsignedEmptyBatchCursor
	}

	return ok
}

type unsignedSumBatchCursor struct {
	tsdb.UnsignedBatchCursor
	ts  int64
	acc uint64
}

func (c *unsignedSumBatchCursor) Next() (key []int64, value []uint64) {
	ks, vs := c.UnsignedBatchCursor.Next()
	if len(ks) == 0 {
		return nil, nil
	}

	ts := ks[0]
	var acc uint64

	for {
		for _, v := range vs {
			acc += v
		}
		ks, vs = c.UnsignedBatchCursor.Next()
		if len(ks) == 0 {
			return []int64{ts}, []uint64{acc}
		}
	}
}

type integerUnsignedCountBatchCursor struct {
	tsdb.UnsignedBatchCursor
}

func (c *integerUnsignedCountBatchCursor) Next() (key []int64, value []int64) {
	ks, _ := c.UnsignedBatchCursor.Next()
	if len(ks) == 0 {
		return nil, nil
	}

	ts := ks[0]
	var acc int64
	for {
		acc += int64(len(ks))
		ks, _ = c.UnsignedBatchCursor.Next()
		if len(ks) == 0 {
			return []int64{ts}, []int64{acc}
		}
	}
}

type unsignedEmptyBatchCursor struct{}

var (
	UnsignedEmptyBatchCursor tsdb.UnsignedBatchCursor = &unsignedEmptyBatchCursor{}
)

func (*unsignedEmptyBatchCursor) Err() error                          { return nil }
func (*unsignedEmptyBatchCursor) Close()                              {}
func (*unsignedEmptyBatchCursor) SeriesKey() string                   { return "" }
func (*unsignedEmptyBatchCursor) Next() (key []int64, value []uint64) { return nil, nil }

// ********************
// String BatchCursor

type stringFilterBatchCursor struct {
	tsdb.StringBatchCursor
	cond expression
	m    *singleValue
	t    []int64
	v    []string
	tb   []int64
	vb   []string
}

func newStringFilterBatchCursor(cur tsdb.StringBatchCursor, cond expression) *stringFilterBatchCursor {
	return &stringFilterBatchCursor{
		StringBatchCursor: cur,
		cond:              cond,
		m:                 &singleValue{},
		t:                 make([]int64, tsdb.DefaultMaxPointsPerBlock),
		v:                 make([]string, tsdb.DefaultMaxPointsPerBlock),
	}
}

func (c *stringFilterBatchCursor) Next() (key []int64, value []string) {
	pos := 0
	var ks []int64
	var vs []string

	if len(c.tb) > 0 {
		ks, vs = c.tb, c.vb
		c.tb, c.vb = nil, nil
	} else {
		ks, vs = c.StringBatchCursor.Next()
	}

LOOP:
	for len(ks) > 0 {
		for i, v := range vs {
			c.m.v = v
			if c.cond.EvalBool(c.m) {
				c.t[pos], c.v[pos] = ks[i], v
				pos++
				if pos >= tsdb.DefaultMaxPointsPerBlock {
					c.tb, c.vb = ks[i+1:], vs[i+1:]
					break LOOP
				}
			}
		}
		ks, vs = c.StringBatchCursor.Next()
	}

	return c.t[:pos], c.v[:pos]
}

type stringMultiShardBatchCursor struct {
	tsdb.StringBatchCursor
	shards []*tsdb.Shard
	req    *tsdb.CursorRequest
	cond   expression
	err    error
}

func newStringMultiShardBatchCursor(cur tsdb.StringBatchCursor, req *tsdb.CursorRequest, shards []*tsdb.Shard, cond expression) *stringMultiShardBatchCursor {
	if cond != nil {
		cur = newStringFilterBatchCursor(cur, cond)
	}

	c := &stringMultiShardBatchCursor{
		StringBatchCursor: cur,
		req:               req,
		shards:            shards,
		cond:              cond,
	}

	return c
}

func (c *stringMultiShardBatchCursor) Err() error        { return c.err }
func (c *stringMultiShardBatchCursor) SeriesKey() string { return c.req.Series }

func (c *stringMultiShardBatchCursor) Next() (key []int64, value []string) {
RETRY:
	ks, vs := c.StringBatchCursor.Next()
	if len(ks) == 0 {
		if c.nextBatchCursor() {
			goto RETRY
		}
	}
	return ks, vs
}

func (c *stringMultiShardBatchCursor) nextBatchCursor() bool {
	if len(c.shards) == 0 {
		return false
	}

	var shard *tsdb.Shard
	var cur tsdb.Cursor
	for cur == nil && len(c.shards) > 0 {
		shard, c.shards = c.shards[0], c.shards[1:]
		cur, _ = shard.CreateCursor(c.req)
	}

	var ok bool
	if cur != nil {
		var next tsdb.StringBatchCursor
		next, ok = cur.(tsdb.StringBatchCursor)
		if !ok {
			next = StringEmptyBatchCursor
			c.shards = nil
			c.err = errors.New("expected string cursor")
		} else {
			if c.cond != nil {
				next = newStringFilterBatchCursor(next, c.cond)
			}
		}
		c.StringBatchCursor = next
	} else {
		c.StringBatchCursor = StringEmptyBatchCursor
	}

	return ok
}

type integerStringCountBatchCursor struct {
	tsdb.StringBatchCursor
}

func (c *integerStringCountBatchCursor) Next() (key []int64, value []int64) {
	ks, _ := c.StringBatchCursor.Next()
	if len(ks) == 0 {
		return nil, nil
	}

	ts := ks[0]
	var acc int64
	for {
		acc += int64(len(ks))
		ks, _ = c.StringBatchCursor.Next()
		if len(ks) == 0 {
			return []int64{ts}, []int64{acc}
		}
	}
}

type stringEmptyBatchCursor struct{}

var (
	StringEmptyBatchCursor tsdb.StringBatchCursor = &stringEmptyBatchCursor{}
)

func (*stringEmptyBatchCursor) Err() error                          { return nil }
func (*stringEmptyBatchCursor) Close()                              {}
func (*stringEmptyBatchCursor) SeriesKey() string                   { return "" }
func (*stringEmptyBatchCursor) Next() (key []int64, value []string) { return nil, nil }

// ********************
// Boolean BatchCursor

type booleanFilterBatchCursor struct {
	tsdb.BooleanBatchCursor
	cond expression
	m    *singleValue
	t    []int64
	v    []bool
	tb   []int64
	vb   []bool
}

func newBooleanFilterBatchCursor(cur tsdb.BooleanBatchCursor, cond expression) *booleanFilterBatchCursor {
	return &booleanFilterBatchCursor{
		BooleanBatchCursor: cur,
		cond:               cond,
		m:                  &singleValue{},
		t:                  make([]int64, tsdb.DefaultMaxPointsPerBlock),
		v:                  make([]bool, tsdb.DefaultMaxPointsPerBlock),
	}
}

func (c *booleanFilterBatchCursor) Next() (key []int64, value []bool) {
	pos := 0
	var ks []int64
	var vs []bool

	if len(c.tb) > 0 {
		ks, vs = c.tb, c.vb
		c.tb, c.vb = nil, nil
	} else {
		ks, vs = c.BooleanBatchCursor.Next()
	}

LOOP:
	for len(ks) > 0 {
		for i, v := range vs {
			c.m.v = v
			if c.cond.EvalBool(c.m) {
				c.t[pos], c.v[pos] = ks[i], v
				pos++
				if pos >= tsdb.DefaultMaxPointsPerBlock {
					c.tb, c.vb = ks[i+1:], vs[i+1:]
					break LOOP
				}
			}
		}
		ks, vs = c.BooleanBatchCursor.Next()
	}

	return c.t[:pos], c.v[:pos]
}

type booleanMultiShardBatchCursor struct {
	tsdb.BooleanBatchCursor
	shards []*tsdb.Shard
	req    *tsdb.CursorRequest
	cond   expression
	err    error
}

func newBooleanMultiShardBatchCursor(cur tsdb.BooleanBatchCursor, req *tsdb.CursorRequest, shards []*tsdb.Shard, cond expression) *booleanMultiShardBatchCursor {
	if cond != nil {
		cur = newBooleanFilterBatchCursor(cur, cond)
	}

	c := &booleanMultiShardBatchCursor{
		BooleanBatchCursor: cur,
		req:                req,
		shards:             shards,
		cond:               cond,
	}

	return c
}

func (c *booleanMultiShardBatchCursor) Err() error        { return c.err }
func (c *booleanMultiShardBatchCursor) SeriesKey() string { return c.req.Series }

func (c *booleanMultiShardBatchCursor) Next() (key []int64, value []bool) {
RETRY:
	ks, vs := c.BooleanBatchCursor.Next()
	if len(ks) == 0 {
		if c.nextBatchCursor() {
			goto RETRY
		}
	}
	return ks, vs
}

func (c *booleanMultiShardBatchCursor) nextBatchCursor() bool {
	if len(c.shards) == 0 {
		return false
	}

	var shard *tsdb.Shard
	var cur tsdb.Cursor
	for cur == nil && len(c.shards) > 0 {
		shard, c.shards = c.shards[0], c.shards[1:]
		cur, _ = shard.CreateCursor(c.req)
	}

	var ok bool
	if cur != nil {
		var next tsdb.BooleanBatchCursor
		next, ok = cur.(tsdb.BooleanBatchCursor)
		if !ok {
			next = BooleanEmptyBatchCursor
			c.shards = nil
			c.err = errors.New("expected boolean cursor")
		} else {
			if c.cond != nil {
				next = newBooleanFilterBatchCursor(next, c.cond)
			}
		}
		c.BooleanBatchCursor = next
	} else {
		c.BooleanBatchCursor = BooleanEmptyBatchCursor
	}

	return ok
}

type integerBooleanCountBatchCursor struct {
	tsdb.BooleanBatchCursor
}

func (c *integerBooleanCountBatchCursor) Next() (key []int64, value []int64) {
	ks, _ := c.BooleanBatchCursor.Next()
	if len(ks) == 0 {
		return nil, nil
	}

	ts := ks[0]
	var acc int64
	for {
		acc += int64(len(ks))
		ks, _ = c.BooleanBatchCursor.Next()
		if len(ks) == 0 {
			return []int64{ts}, []int64{acc}
		}
	}
}

type booleanEmptyBatchCursor struct{}

var (
	BooleanEmptyBatchCursor tsdb.BooleanBatchCursor = &booleanEmptyBatchCursor{}
)

func (*booleanEmptyBatchCursor) Err() error                        { return nil }
func (*booleanEmptyBatchCursor) Close()                            {}
func (*booleanEmptyBatchCursor) SeriesKey() string                 { return "" }
func (*booleanEmptyBatchCursor) Next() (key []int64, value []bool) { return nil, nil }
