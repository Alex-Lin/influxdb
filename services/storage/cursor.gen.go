// Generated by tmpl
// https://github.com/benbjohnson/tmpl
//
// DO NOT EDIT!
// Source: cursor.gen.go.tmpl

package storage

import (
	"errors"

	"github.com/influxdata/influxdb/tsdb"
)

// ********************
// Float Cursor

type floatFilterCursor struct {
	tsdb.FloatCursor
	cond expression
	m    *singleValue
}

func newFloatFilterCursor(cur tsdb.FloatCursor, cond expression) *floatFilterCursor {
	return &floatFilterCursor{FloatCursor: cur, cond: cond, m: &singleValue{}}
}

func (c *floatFilterCursor) Next() (key int64, value float64) {
	for {
		k, v := c.FloatCursor.Next()
		if k == tsdb.EOF {
			return k, v
		}

		c.m.v = v
		if !c.cond.EvalBool(c.m) {
			continue
		}
		return k, v
	}
}

type floatMultiShardCursor struct {
	tsdb.FloatCursor
	shards []*tsdb.Shard
	req    *tsdb.CursorRequest
	cond   expression
	err    error
}

func newFloatMultiShardCursor(cur tsdb.FloatCursor, req *tsdb.CursorRequest, shards []*tsdb.Shard, cond expression) *floatMultiShardCursor {
	if cond != nil {
		cur = newFloatFilterCursor(cur, cond)
	}

	c := &floatMultiShardCursor{
		FloatCursor: cur,
		req:         req,
		shards:      shards,
		cond:        cond,
	}

	return c
}

func (c *floatMultiShardCursor) Err() error        { return c.err }
func (c *floatMultiShardCursor) SeriesKey() string { return c.req.Series }

func (c *floatMultiShardCursor) Next() (key int64, value float64) {
RETRY:
	k, v := c.FloatCursor.Next()
	if k == tsdb.EOF {
		if c.nextCursor() {
			goto RETRY
		}
	}
	return k, v
}

func (c *floatMultiShardCursor) nextCursor() bool {
	if len(c.shards) == 0 {
		return false
	}

	var shard *tsdb.Shard
	var cur tsdb.Cursor
	for cur == nil && len(c.shards) > 0 {
		shard, c.shards = c.shards[0], c.shards[1:]
		cur, _ = shard.CreateCursor(c.req)
	}

	var ok bool
	if cur != nil {
		var next tsdb.FloatCursor
		next, ok = cur.(tsdb.FloatCursor)
		if !ok {
			next = FloatEmptyCursor
			c.shards = nil
			c.err = errors.New("expected float cursor")
		} else {
			if c.cond != nil {
				next = newFloatFilterCursor(next, c.cond)
			}
		}
		c.FloatCursor = next
	} else {
		c.FloatCursor = FloatEmptyCursor
	}

	return ok
}

type floatSumCursor struct {
	tsdb.FloatCursor
	ts  int64
	acc float64
}

func (c *floatSumCursor) Next() (key int64, value float64) {
	c.ts, c.acc = c.FloatCursor.Next()
	for {
		k, v := c.FloatCursor.Next()
		if k == tsdb.EOF {
			return c.ts, c.acc
		}

		c.acc += v
	}
}

type integerFloatCountCursor struct {
	tsdb.FloatCursor
	ts  int64
	acc int64
}

func (c *integerFloatCountCursor) Next() (key int64, value int64) {
	c.ts, _ = c.FloatCursor.Next()
	var k = c.ts
	for k != tsdb.EOF {
		c.acc += 1
		k, _ = c.FloatCursor.Next()
	}
	return c.ts, c.acc
}

type floatEmptyCursor struct{}

var (
	FloatEmptyCursor tsdb.FloatCursor = &floatEmptyCursor{}
)

func (*floatEmptyCursor) Err() error                       { return nil }
func (*floatEmptyCursor) Close()                           {}
func (*floatEmptyCursor) SeriesKey() string                { return "" }
func (*floatEmptyCursor) Next() (key int64, value float64) { return tsdb.EOF, 0 }

// ********************
// Integer Cursor

type integerFilterCursor struct {
	tsdb.IntegerCursor
	cond expression
	m    *singleValue
}

func newIntegerFilterCursor(cur tsdb.IntegerCursor, cond expression) *integerFilterCursor {
	return &integerFilterCursor{IntegerCursor: cur, cond: cond, m: &singleValue{}}
}

func (c *integerFilterCursor) Next() (key int64, value int64) {
	for {
		k, v := c.IntegerCursor.Next()
		if k == tsdb.EOF {
			return k, v
		}

		c.m.v = v
		if !c.cond.EvalBool(c.m) {
			continue
		}
		return k, v
	}
}

type integerMultiShardCursor struct {
	tsdb.IntegerCursor
	shards []*tsdb.Shard
	req    *tsdb.CursorRequest
	cond   expression
	err    error
}

func newIntegerMultiShardCursor(cur tsdb.IntegerCursor, req *tsdb.CursorRequest, shards []*tsdb.Shard, cond expression) *integerMultiShardCursor {
	if cond != nil {
		cur = newIntegerFilterCursor(cur, cond)
	}

	c := &integerMultiShardCursor{
		IntegerCursor: cur,
		req:           req,
		shards:        shards,
		cond:          cond,
	}

	return c
}

func (c *integerMultiShardCursor) Err() error        { return c.err }
func (c *integerMultiShardCursor) SeriesKey() string { return c.req.Series }

func (c *integerMultiShardCursor) Next() (key int64, value int64) {
RETRY:
	k, v := c.IntegerCursor.Next()
	if k == tsdb.EOF {
		if c.nextCursor() {
			goto RETRY
		}
	}
	return k, v
}

func (c *integerMultiShardCursor) nextCursor() bool {
	if len(c.shards) == 0 {
		return false
	}

	var shard *tsdb.Shard
	var cur tsdb.Cursor
	for cur == nil && len(c.shards) > 0 {
		shard, c.shards = c.shards[0], c.shards[1:]
		cur, _ = shard.CreateCursor(c.req)
	}

	var ok bool
	if cur != nil {
		var next tsdb.IntegerCursor
		next, ok = cur.(tsdb.IntegerCursor)
		if !ok {
			next = IntegerEmptyCursor
			c.shards = nil
			c.err = errors.New("expected integer cursor")
		} else {
			if c.cond != nil {
				next = newIntegerFilterCursor(next, c.cond)
			}
		}
		c.IntegerCursor = next
	} else {
		c.IntegerCursor = IntegerEmptyCursor
	}

	return ok
}

type integerSumCursor struct {
	tsdb.IntegerCursor
	ts  int64
	acc int64
}

func (c *integerSumCursor) Next() (key int64, value int64) {
	c.ts, c.acc = c.IntegerCursor.Next()
	for {
		k, v := c.IntegerCursor.Next()
		if k == tsdb.EOF {
			return c.ts, c.acc
		}

		c.acc += v
	}
}

type integerIntegerCountCursor struct {
	tsdb.IntegerCursor
	ts  int64
	acc int64
}

func (c *integerIntegerCountCursor) Next() (key int64, value int64) {
	c.ts, _ = c.IntegerCursor.Next()
	var k = c.ts
	for k != tsdb.EOF {
		c.acc += 1
		k, _ = c.IntegerCursor.Next()
	}
	return c.ts, c.acc
}

type integerEmptyCursor struct{}

var (
	IntegerEmptyCursor tsdb.IntegerCursor = &integerEmptyCursor{}
)

func (*integerEmptyCursor) Err() error                     { return nil }
func (*integerEmptyCursor) Close()                         {}
func (*integerEmptyCursor) SeriesKey() string              { return "" }
func (*integerEmptyCursor) Next() (key int64, value int64) { return tsdb.EOF, 0 }

// ********************
// Unsigned Cursor

type unsignedFilterCursor struct {
	tsdb.UnsignedCursor
	cond expression
	m    *singleValue
}

func newUnsignedFilterCursor(cur tsdb.UnsignedCursor, cond expression) *unsignedFilterCursor {
	return &unsignedFilterCursor{UnsignedCursor: cur, cond: cond, m: &singleValue{}}
}

func (c *unsignedFilterCursor) Next() (key int64, value uint64) {
	for {
		k, v := c.UnsignedCursor.Next()
		if k == tsdb.EOF {
			return k, v
		}

		c.m.v = v
		if !c.cond.EvalBool(c.m) {
			continue
		}
		return k, v
	}
}

type unsignedMultiShardCursor struct {
	tsdb.UnsignedCursor
	shards []*tsdb.Shard
	req    *tsdb.CursorRequest
	cond   expression
	err    error
}

func newUnsignedMultiShardCursor(cur tsdb.UnsignedCursor, req *tsdb.CursorRequest, shards []*tsdb.Shard, cond expression) *unsignedMultiShardCursor {
	if cond != nil {
		cur = newUnsignedFilterCursor(cur, cond)
	}

	c := &unsignedMultiShardCursor{
		UnsignedCursor: cur,
		req:            req,
		shards:         shards,
		cond:           cond,
	}

	return c
}

func (c *unsignedMultiShardCursor) Err() error        { return c.err }
func (c *unsignedMultiShardCursor) SeriesKey() string { return c.req.Series }

func (c *unsignedMultiShardCursor) Next() (key int64, value uint64) {
RETRY:
	k, v := c.UnsignedCursor.Next()
	if k == tsdb.EOF {
		if c.nextCursor() {
			goto RETRY
		}
	}
	return k, v
}

func (c *unsignedMultiShardCursor) nextCursor() bool {
	if len(c.shards) == 0 {
		return false
	}

	var shard *tsdb.Shard
	var cur tsdb.Cursor
	for cur == nil && len(c.shards) > 0 {
		shard, c.shards = c.shards[0], c.shards[1:]
		cur, _ = shard.CreateCursor(c.req)
	}

	var ok bool
	if cur != nil {
		var next tsdb.UnsignedCursor
		next, ok = cur.(tsdb.UnsignedCursor)
		if !ok {
			next = UnsignedEmptyCursor
			c.shards = nil
			c.err = errors.New("expected unsigned cursor")
		} else {
			if c.cond != nil {
				next = newUnsignedFilterCursor(next, c.cond)
			}
		}
		c.UnsignedCursor = next
	} else {
		c.UnsignedCursor = UnsignedEmptyCursor
	}

	return ok
}

type unsignedSumCursor struct {
	tsdb.UnsignedCursor
	ts  int64
	acc uint64
}

func (c *unsignedSumCursor) Next() (key int64, value uint64) {
	c.ts, c.acc = c.UnsignedCursor.Next()
	for {
		k, v := c.UnsignedCursor.Next()
		if k == tsdb.EOF {
			return c.ts, c.acc
		}

		c.acc += v
	}
}

type integerUnsignedCountCursor struct {
	tsdb.UnsignedCursor
	ts  int64
	acc int64
}

func (c *integerUnsignedCountCursor) Next() (key int64, value int64) {
	c.ts, _ = c.UnsignedCursor.Next()
	var k = c.ts
	for k != tsdb.EOF {
		c.acc += 1
		k, _ = c.UnsignedCursor.Next()
	}
	return c.ts, c.acc
}

type unsignedEmptyCursor struct{}

var (
	UnsignedEmptyCursor tsdb.UnsignedCursor = &unsignedEmptyCursor{}
)

func (*unsignedEmptyCursor) Err() error                      { return nil }
func (*unsignedEmptyCursor) Close()                          {}
func (*unsignedEmptyCursor) SeriesKey() string               { return "" }
func (*unsignedEmptyCursor) Next() (key int64, value uint64) { return tsdb.EOF, 0 }

// ********************
// String Cursor

type stringFilterCursor struct {
	tsdb.StringCursor
	cond expression
	m    *singleValue
}

func newStringFilterCursor(cur tsdb.StringCursor, cond expression) *stringFilterCursor {
	return &stringFilterCursor{StringCursor: cur, cond: cond, m: &singleValue{}}
}

func (c *stringFilterCursor) Next() (key int64, value string) {
	for {
		k, v := c.StringCursor.Next()
		if k == tsdb.EOF {
			return k, v
		}

		c.m.v = v
		if !c.cond.EvalBool(c.m) {
			continue
		}
		return k, v
	}
}

type stringMultiShardCursor struct {
	tsdb.StringCursor
	shards []*tsdb.Shard
	req    *tsdb.CursorRequest
	cond   expression
	err    error
}

func newStringMultiShardCursor(cur tsdb.StringCursor, req *tsdb.CursorRequest, shards []*tsdb.Shard, cond expression) *stringMultiShardCursor {
	if cond != nil {
		cur = newStringFilterCursor(cur, cond)
	}

	c := &stringMultiShardCursor{
		StringCursor: cur,
		req:          req,
		shards:       shards,
		cond:         cond,
	}

	return c
}

func (c *stringMultiShardCursor) Err() error        { return c.err }
func (c *stringMultiShardCursor) SeriesKey() string { return c.req.Series }

func (c *stringMultiShardCursor) Next() (key int64, value string) {
RETRY:
	k, v := c.StringCursor.Next()
	if k == tsdb.EOF {
		if c.nextCursor() {
			goto RETRY
		}
	}
	return k, v
}

func (c *stringMultiShardCursor) nextCursor() bool {
	if len(c.shards) == 0 {
		return false
	}

	var shard *tsdb.Shard
	var cur tsdb.Cursor
	for cur == nil && len(c.shards) > 0 {
		shard, c.shards = c.shards[0], c.shards[1:]
		cur, _ = shard.CreateCursor(c.req)
	}

	var ok bool
	if cur != nil {
		var next tsdb.StringCursor
		next, ok = cur.(tsdb.StringCursor)
		if !ok {
			next = StringEmptyCursor
			c.shards = nil
			c.err = errors.New("expected string cursor")
		} else {
			if c.cond != nil {
				next = newStringFilterCursor(next, c.cond)
			}
		}
		c.StringCursor = next
	} else {
		c.StringCursor = StringEmptyCursor
	}

	return ok
}

type integerStringCountCursor struct {
	tsdb.StringCursor
	ts  int64
	acc int64
}

func (c *integerStringCountCursor) Next() (key int64, value int64) {
	c.ts, _ = c.StringCursor.Next()
	var k = c.ts
	for k != tsdb.EOF {
		c.acc += 1
		k, _ = c.StringCursor.Next()
	}
	return c.ts, c.acc
}

type stringEmptyCursor struct{}

var (
	StringEmptyCursor tsdb.StringCursor = &stringEmptyCursor{}
)

func (*stringEmptyCursor) Err() error                      { return nil }
func (*stringEmptyCursor) Close()                          {}
func (*stringEmptyCursor) SeriesKey() string               { return "" }
func (*stringEmptyCursor) Next() (key int64, value string) { return tsdb.EOF, "" }

// ********************
// Boolean Cursor

type booleanFilterCursor struct {
	tsdb.BooleanCursor
	cond expression
	m    *singleValue
}

func newBooleanFilterCursor(cur tsdb.BooleanCursor, cond expression) *booleanFilterCursor {
	return &booleanFilterCursor{BooleanCursor: cur, cond: cond, m: &singleValue{}}
}

func (c *booleanFilterCursor) Next() (key int64, value bool) {
	for {
		k, v := c.BooleanCursor.Next()
		if k == tsdb.EOF {
			return k, v
		}

		c.m.v = v
		if !c.cond.EvalBool(c.m) {
			continue
		}
		return k, v
	}
}

type booleanMultiShardCursor struct {
	tsdb.BooleanCursor
	shards []*tsdb.Shard
	req    *tsdb.CursorRequest
	cond   expression
	err    error
}

func newBooleanMultiShardCursor(cur tsdb.BooleanCursor, req *tsdb.CursorRequest, shards []*tsdb.Shard, cond expression) *booleanMultiShardCursor {
	if cond != nil {
		cur = newBooleanFilterCursor(cur, cond)
	}

	c := &booleanMultiShardCursor{
		BooleanCursor: cur,
		req:           req,
		shards:        shards,
		cond:          cond,
	}

	return c
}

func (c *booleanMultiShardCursor) Err() error        { return c.err }
func (c *booleanMultiShardCursor) SeriesKey() string { return c.req.Series }

func (c *booleanMultiShardCursor) Next() (key int64, value bool) {
RETRY:
	k, v := c.BooleanCursor.Next()
	if k == tsdb.EOF {
		if c.nextCursor() {
			goto RETRY
		}
	}
	return k, v
}

func (c *booleanMultiShardCursor) nextCursor() bool {
	if len(c.shards) == 0 {
		return false
	}

	var shard *tsdb.Shard
	var cur tsdb.Cursor
	for cur == nil && len(c.shards) > 0 {
		shard, c.shards = c.shards[0], c.shards[1:]
		cur, _ = shard.CreateCursor(c.req)
	}

	var ok bool
	if cur != nil {
		var next tsdb.BooleanCursor
		next, ok = cur.(tsdb.BooleanCursor)
		if !ok {
			next = BooleanEmptyCursor
			c.shards = nil
			c.err = errors.New("expected boolean cursor")
		} else {
			if c.cond != nil {
				next = newBooleanFilterCursor(next, c.cond)
			}
		}
		c.BooleanCursor = next
	} else {
		c.BooleanCursor = BooleanEmptyCursor
	}

	return ok
}

type integerBooleanCountCursor struct {
	tsdb.BooleanCursor
	ts  int64
	acc int64
}

func (c *integerBooleanCountCursor) Next() (key int64, value int64) {
	c.ts, _ = c.BooleanCursor.Next()
	var k = c.ts
	for k != tsdb.EOF {
		c.acc += 1
		k, _ = c.BooleanCursor.Next()
	}
	return c.ts, c.acc
}

type booleanEmptyCursor struct{}

var (
	BooleanEmptyCursor tsdb.BooleanCursor = &booleanEmptyCursor{}
)

func (*booleanEmptyCursor) Err() error                    { return nil }
func (*booleanEmptyCursor) Close()                        {}
func (*booleanEmptyCursor) SeriesKey() string             { return "" }
func (*booleanEmptyCursor) Next() (key int64, value bool) { return tsdb.EOF, false }
